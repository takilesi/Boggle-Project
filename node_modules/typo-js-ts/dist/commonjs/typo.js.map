{"version":3,"file":"typo.js","sources":["../../scratch/main/index.js"],"sourcesContent":["// BUILD_INCLUDE(\"src/typo/legacy/imports.js\")\n/**\n * Typo is a JavaScript implementation of a spellchecker using hunspell-style\n * dictionaries.\n */\nexport class Typo {\n    //#region Constructor\n    /**\n     * Typo constructor.\n     * @param {string} [dictionary] The locale code of the dictionary being used.e.g.,\n     * \"en_US\".This is only used to auto - load dictionaries.\n     * @param {String} [affData] The data from the dictionary 's .aff file. If omitted\n     * and Typo.js is being used in a Chrome extension, the.aff\n     * file will be loaded automatically from\n     * lib / typo / dictionaries / [dictionary] / [dictionary].aff\n     * In other environments,it will be loaded from\n     * [settings.dictionaryPath] / dictionaries / [dictionary] / [dictionary].aff\n     * @param {String} [wordsData] The data from the dictionary 's .dic file. If omitted\n     * and Typo.js is being used in a Chrome extension, the.dic\n     * file will be loaded automatically from * lib / typo / dictionaries / [dictionary] / [dictionary].dic\n     * In other environments, it will be loaded from\n     * [settings.dictionaryPath] / dictionaries / [dictionary] / [dictionary].dic\n     * @param {Object} [settings] Constructor settings.Available properties are :\n     * {String}[dictionaryPath] : path to load dictionary from in non - chrome\n     * environment.\n     * {Object}[flags] : flag information.\n     * {Boolean}[asyncLoad] : If true, affData and wordsData will be loaded\n     * asynchronously.\n     * {Function}[loadedCallback] : Called when both affData and wordsData\n     * have been loaded.Only used if asyncLoad is set to true.The parameter\n     * is the instantiated Typo object.\n     */\n    constructor(dictionary, affData, wordsData, settings) {\n        this.ERR_NOT_LOAD = \"Dictionary not loaded\";\n        this.ALPHABET = \"abcdefghijklmnopqrstuvwxyz\";\n        this.lDictionary = '';\n        /**\n        * Object that will contain and entry of IRuleCodes for each\n        * dynamically added key\n        */\n        this.rules = {};\n        // dictionaryTable seems to be an object full or arrays for elements in the dom.\n        this.dictionaryTable = {};\n        this.compoundRules = [];\n        this.compoundRuleCodes = {};\n        this.replacementTable = new Array();\n        this.memoized = {};\n        this.loaded = false;\n        this.options = settings || { flags: {} };\n        if (settings !== undefined && settings !== null) {\n            if (settings.flags !== undefined) {\n                this.flags = settings.flags;\n            }\n            else {\n                this.flags = {};\n            }\n        }\n        else {\n            this.flags = {};\n        }\n        const readDataFile = (url) => {\n            const response = this._readFile(url, null);\n            return response;\n            // response.then(text => {\n            // \tsetFunc(text);\n            // }).catch(error => {\n            // \tconsole.error(error);\n            // });\n        };\n        const init = async (dic, aff, wData) => {\n            const setAffData = (data) => {\n                aff = data;\n                if (wData) {\n                    setup();\n                }\n            };\n            const setWordsData = (data) => {\n                wData = data;\n                if (aff) {\n                    setup();\n                }\n            };\n            const setup = () => {\n                if (!aff) {\n                    return;\n                }\n                if (!wData) {\n                    return;\n                }\n                this.rules = this._parseAFF(aff);\n                // Save the rule codes that are used in compound rules.\n                this.compoundRuleCodes = {};\n                for (const rule of this.compoundRules) {\n                    if (typeof rule === 'string') {\n                        for (let j = 0; j < rule.length; j++) {\n                            this.compoundRuleCodes[rule.charAt(j)] = [];\n                        }\n                    }\n                }\n                // If we add this ONLYINCOMPOUND flag to self.compoundRuleCodes, then _parseDIC\n                // will do the work of saving the list of words that are compound-only.\n                if (this.flags.ONLYINCOMPOUND) {\n                    this.compoundRuleCodes[this.flags.ONLYINCOMPOUND] = [];\n                }\n                this.dictionaryTable = this._parseDIC(wData);\n                // Get rid of any codes from the compound rule codes that are never used\n                // (or that were special regex characters).  Not especially necessary...\n                for (const iKey in this.compoundRuleCodes) {\n                    if (Object.prototype.hasOwnProperty.call(this.compoundRuleCodes, iKey)) {\n                        if (this.compoundRuleCodes[iKey].length === 0) {\n                            delete this.compoundRuleCodes[iKey];\n                        }\n                    }\n                }\n                // Build the full regular expressions for each compound rule.\n                // I have a feeling (but no confirmation yet) that this method of\n                // testing for compound words is probably slow.\n                i = 0;\n                for (const ruleText of this.compoundRules) {\n                    let expressionText = \"\";\n                    if (typeof ruleText === 'string') {\n                        for (const character of ruleText) {\n                            if (character in this.compoundRuleCodes) {\n                                expressionText += \"(\" + this.compoundRuleCodes[character].join(\"|\") + \")\";\n                            }\n                            else {\n                                expressionText += character;\n                            }\n                        }\n                        this.compoundRules[i] = new RegExp(expressionText, \"i\");\n                        i++;\n                    }\n                }\n            };\n            const isChromeExt = () => {\n                if (typeof window.chrome?.runtime?.getURL === 'function') {\n                    return true;\n                }\n                return false;\n            };\n            const isBrowserExt = () => {\n                if (typeof window.browser?.runtime?.getURL === 'function') {\n                    return true;\n                }\n                return false;\n            };\n            let path;\n            let pLoadDataAff;\n            let pLoadDataDic;\n            // Loop-control variables.\n            let i;\n            if (dic) {\n                this.lDictionary = dic;\n                // If the data is preloaded, just setup the Typo object.\n                if (aff && wData) {\n                    setup();\n                }\n                // Loading data for Browser extentions.\n                else if (typeof window !== 'undefined' && (isChromeExt() === true || isBrowserExt() === true)) {\n                    if (this.options.dictionaryPath) {\n                        path = this.options.dictionaryPath;\n                    }\n                    else {\n                        path = \"typo/dictionaries\";\n                    }\n                    let getURL;\n                    if (isChromeExt() === true) {\n                        getURL = window.chrome.runtime.getURL;\n                    }\n                    else {\n                        getURL = window.browser.runtime.getURL;\n                    }\n                    if (!aff) {\n                        pLoadDataAff = readDataFile(getURL(path + \"/\" + dic + \"/\" + dic + \".aff\"))\n                            .then(affD => {\n                            setAffData(affD);\n                        });\n                    }\n                    if (!wData) {\n                        pLoadDataDic = readDataFile(getURL(path + \"/\" + dic + \"/\" + dic + \".dic\"))\n                            .then(wordsD => {\n                            setWordsData(wordsD);\n                        });\n                    }\n                }\n                else {\n                    if (this.options.dictionaryPath) {\n                        path = this.options.dictionaryPath;\n                    }\n                    else if (typeof __dirname !== 'undefined') {\n                        path = __dirname + '/dictionaries';\n                    }\n                    else {\n                        path = './dictionaries';\n                    }\n                    if (!aff) {\n                        pLoadDataAff = readDataFile(path + \"/\" + dic + \"/\" + dic + \".aff\")\n                            .then(affD => {\n                            setAffData(affD);\n                        });\n                    }\n                    if (!wData) {\n                        pLoadDataDic = readDataFile(path + \"/\" + dic + \"/\" + dic + \".dic\")\n                            .then(wordsD => {\n                            setWordsData(wordsD);\n                        });\n                    }\n                }\n            }\n            return new Promise((resolve, reject) => {\n                Promise.all([pLoadDataDic, pLoadDataAff])\n                    .then(() => { resolve(true); })\n                    .catch(err => { reject(err); });\n            });\n        };\n        this.readyPromise = new Promise((resolve, reject) => {\n            init(dictionary, affData, wordsData)\n                .then(() => {\n                resolve(this);\n            })\n                .catch((err) => {\n                reject(err);\n            });\n        });\n        if (this.options.loadedCallback) {\n            this.ready.then();\n        }\n    }\n    //#endregion Constructor\n    //#region  Properties\n    get ready() {\n        const doCallBacks = (err, t) => {\n            if (this.options.loadedCallback) {\n                if (typeof this.options.loadedCallback === 'function') {\n                    this.options.loadedCallback(err, t);\n                }\n                else if (typeof this.options.loadedCallback === 'object') {\n                    this.options.loadedCallback.forEach(fn => {\n                        fn(err, t);\n                    });\n                }\n            }\n        };\n        return this.readyPromise.then(() => {\n            this.loaded = true; // store the result\n            doCallBacks(null, this);\n            return this; // this is what makes the one-liner possible!\n        })\n            .catch(err => {\n            doCallBacks(err, this);\n            throw err;\n        });\n    }\n    get dictionary() {\n        if (this.lDictionary === '') {\n            return null;\n        }\n        return this.lDictionary;\n    }\n    //#endregion properties\n    /**\n     * Loads a Typo instance from a hash of all of the Typo properties.\n     *\n     * @param {object} obj A hash of Typo properties, probably gotten from a JSON.parse(JSON.stringify(typo_instance)).\n     */\n    load(obj) {\n        for (const i in obj) {\n            if (obj.hasOwnProperty(i) && Object(this).hasOwnProperty(i)) {\n                const val = obj[i];\n                Object.defineProperty(this, i.toString(), {\n                    value: val,\n                    writable: true,\n                    enumerable: true,\n                    configurable: true\n                });\n                // this[i] = obj[i];\n            }\n        }\n        return this;\n    }\n    // #region _readFile function\n    /**\n     * Read the contents of a file.\n     *\n     * @param {String} path The path (relative) to the file.\n     * @param {String|null} charset The expected charset of the file, If null default to utf8\n     * @param {Boolean} async If true, the file will be read asynchronously. For node.js this does nothing, all\n     * files are read synchronously.\n     * @returns {String} The file data if async is false, otherwise a promise object. If running node.js, the data is\n     * always returned.\n     */\n    _readFile(path, charset) {\n        charset = charset || \"utf8\";\n        if (typeof window !== 'undefined') {\n            const requestHeaders = new Headers();\n            requestHeaders.set('Content-Type', \"text/plain; charset=\" + charset);\n            return fetch(path, {\n                method: 'GET',\n                headers: requestHeaders\n            }).then((response) => response.text());\n            ;\n        }\n        else if (typeof require !== 'undefined') { // Node.js\n            const fs = require(\"fs\");\n            let result = '';\n            let err = null;\n            try {\n                if (fs.existsSync(path)) {\n                    result = fs.readFileSync(path, charset);\n                }\n                else {\n                    throw new Error(\"Path \" + path + \" does not exist.\");\n                }\n            }\n            catch (e) {\n                err = e;\n            }\n            if (err !== null) {\n                return Promise.reject(err);\n            }\n            return Promise.resolve(result);\n        }\n        return Promise.reject(new Error('An Error occured getting dictionary'));\n    }\n    // #endregion _readFile function\n    // #region _parseAFF\n    _parseAFF(data) {\n        const rules = {};\n        let line;\n        let subline;\n        let numEntries;\n        let lineParts;\n        let i;\n        let j = 0;\n        let iLen = 0;\n        let jLen = 0;\n        // Remove comment lines\n        data = this._removeAffixComments(data);\n        const lines = data.split(/\\r?\\n/);\n        iLen = lines.length;\n        for (i = 0; i < iLen; i++) {\n            line = lines[i];\n            const definitionParts = line.split(/\\s+/);\n            const ruleType = definitionParts[0].toUpperCase();\n            if (ruleType === \"PFX\" || ruleType === \"SFX\") {\n                const ruleCode = definitionParts[1];\n                const combineable = definitionParts[2].toUpperCase();\n                numEntries = parseInt(definitionParts[3], 10);\n                const entries = [];\n                if (isNaN(numEntries) === false) {\n                    for (j = i + 1, jLen = i + 1 + numEntries; j < jLen; j++) {\n                        subline = lines[j];\n                        lineParts = subline.split(/\\s+/);\n                        const charactersToRemove = lineParts[2];\n                        const additionParts = lineParts[3].split(\"/\");\n                        let charactersToAdd = additionParts[0];\n                        if (charactersToAdd === \"0\") {\n                            charactersToAdd = \"\";\n                        }\n                        const continuationClasses = this.parseRuleCodes(additionParts[1]);\n                        const regexToMatch = lineParts[4];\n                        const entry = {\n                            add: charactersToAdd\n                        };\n                        if (continuationClasses.length > 0) {\n                            entry.continuationClasses = continuationClasses;\n                        }\n                        if (regexToMatch !== \".\") {\n                            if (ruleType === \"SFX\") {\n                                entry.match = new RegExp(regexToMatch + \"$\");\n                            }\n                            else {\n                                entry.match = new RegExp(\"^\" + regexToMatch);\n                            }\n                        }\n                        if (charactersToRemove.toString() !== \"0\") {\n                            if (ruleType === \"SFX\") {\n                                entry.remove = new RegExp(charactersToRemove + \"$\");\n                            }\n                            else {\n                                // in original Typo.js this was added as string\n                                // entry.remove = charactersToRemove;\n                                entry.remove = new RegExp(charactersToRemove);\n                            }\n                        }\n                        entries.push(entry);\n                    }\n                }\n                rules[ruleCode] = {\n                    \"type\": ruleType,\n                    \"combineable\": (combineable === \"Y\"),\n                    \"entries\": entries\n                };\n                i += numEntries;\n            }\n            else if (ruleType === \"COMPOUNDRULE\") {\n                numEntries = parseInt(definitionParts[1], 10);\n                for (j = i + 1, jLen = i + 1 + numEntries; j < jLen; j++) {\n                    line = lines[j];\n                    lineParts = line.split(/\\s+/);\n                    // When the regexp parameter is a string or a number,\n                    // it is implicitly converted to a RegExp by using new RegExp(regexp).\n                    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match\n                    this.compoundRules.push(lineParts[1]);\n                }\n                i += numEntries;\n            }\n            else if (ruleType === \"REP\") {\n                lineParts = line.split(/\\s+/);\n                if (lineParts.length === 3) {\n                    this.replacementTable.push([\n                        lineParts[1], lineParts[2]\n                    ]);\n                }\n            }\n            else {\n                // ONLYINCOMPOUND\n                // COMPOUNDMIN\n                // FLAG\n                // KEEPCASE\n                // NEEDAFFIX\n                this.flags[ruleType] = definitionParts[1];\n            }\n        }\n        return rules;\n    }\n    // #endregion _parseAFF\n    // #region _removeAffixComments\n    /**\n         * Removes comment lines and then cleans up blank lines and trailing whitespace.\n         *\n         * @param {String} data The data from an affix file.\n         * @return {String} The cleaned-up data.\n         */\n    _removeAffixComments(data) {\n        // Remove comments\n        // This used to remove any string starting with '#' up to the end of the line,\n        // but some COMPOUNDRULE definitions include '#' as part of the rule.\n        // I haven't seen any affix files that use comments on the same line as real data,\n        // so I don't think this will break anything.\n        const str = data.replace(/^\\s*#.*$/mg, \"\")\n            // Trim each line\n            .replace(/^\\s\\s*/m, '')\n            .replace(/\\s\\s*$/m, '')\n            // Remove blank lines.\n            .replace(/\\n{2,}/g, \"\\n\")\n            // Trim the entire string\n            .replace(/^\\s\\s*/, '')\n            .replace(/\\s\\s*$/, '');\n        return str;\n    }\n    // #endregion _removeAffixComments\n    // #region _parseDIC\n    /**\n     * Parses the words out from the .dic file.\n     *\n     * @param {String} data The data from the dictionary file.\n     * @returns object The lookup table containing all of the words and\n     *                 word forms from the dictionary.\n    * The dictionary table looks similar to the folowng.\n    * Note the dictionary table can have more than 20,000 entries\n    ````js\n        var dictionaryTable = {\n            \"1\": [[\"n\", \"m\"]],\n            \"2\": [[\"n\", \"1\"]],\n            \"d\": [[\"J\", \"G\", \"V\", \"X\"]]\n            };\n     ````\n     */\n    _parseDIC(data) {\n        data = this._removeDicComments(data);\n        const lines = data.split(/\\r?\\n/);\n        const dictionaryTable = {};\n        /**\n         * Pushes a string array on dictionary table\n         * @param {strng} key The key to add or append rules to\n         * @param {string[]} rules string array of rules to add.\n         *\n         * The dictionary table looks similar to the folowng.\n         * Note the dictionary table can have more than 20,000 entries\n         ```js\n        var dictionaryTable = {\n            \"1\": [[\"n\", \"m\"]],\n            \"2\": [[\"n\", \"1\"]],\n            \"d\": [[\"J\", \"G\", \"V\", \"X\"]]\n            };\n         ```\n         */\n        const addWord = (key, rules) => {\n            if (!dictionaryTable.hasOwnProperty(key)) {\n                dictionaryTable[key] = null;\n            }\n            if (rules.length > 0) {\n                let el = dictionaryTable[key];\n                if (el === null || el === undefined) {\n                    el = [];\n                    dictionaryTable[key] = el;\n                }\n                el.push(rules);\n            }\n        };\n        // The first line is the number of words in the dictionary.\n        for (let i = 1; i < lines.length; i++) {\n            const line = lines[i];\n            if (!line) { // Ignore empty lines.\n                continue;\n            }\n            const parts = line.split(\"/\", 2);\n            const word = parts[0];\n            // Now for each affix rule, generate that form of the word.\n            if (parts.length > 1) {\n                const ruleCodesArray = this.parseRuleCodes(parts[1]);\n                // Save the ruleCodes for compound word situations.\n                if (!(this.flags.NEEDAFFIX)\n                    || (this.flags.NEEDAFFIX && ruleCodesArray.indexOf(this.flags.NEEDAFFIX) === -1)) {\n                    addWord(word, ruleCodesArray);\n                }\n                const jlen = ruleCodesArray.length;\n                for (let j = 0; j < jlen; j++) {\n                    const code = ruleCodesArray[j];\n                    const rule = this.rules[code];\n                    if (rule) {\n                        const newWords = this._applyRule(word, rule);\n                        for (const newWord of newWords) {\n                            addWord(newWord, []);\n                            if (rule.combineable) {\n                                for (let k = j + 1; k < jlen; k++) {\n                                    const combineCode = ruleCodesArray[k];\n                                    const combineRule = this.rules[combineCode];\n                                    if (combineRule) {\n                                        if (combineRule.combineable && (rule.type !== combineRule.type)) {\n                                            const otherNewWords = this._applyRule(newWord, combineRule);\n                                            for (const otherNewWord of otherNewWords) {\n                                                addWord(otherNewWord, []);\n                                            }\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                    if (code in this.compoundRuleCodes) {\n                        this.compoundRuleCodes[code].push(word);\n                    }\n                }\n            }\n            else {\n                addWord(word.trim(), []);\n            }\n        }\n        return dictionaryTable;\n    }\n    // #endregion _parseDIC\n    // #region _removeDicComments\n    /**\n     * Removes comment lines and then cleans up blank lines and trailing whitespace.\n     *\n     * @param {String} data The data from a .dic file.\n     * @return {String} The cleaned-up data.\n     */\n    _removeDicComments(data) {\n        // I can't find any official documentation on it, but at least the de_DE\n        // dictionary uses tab-indented lines as comments.\n        // Remove comments\n        return data.replace(/^\\t.*$/mg, \"\");\n    }\n    // #endregion _removeDicComments\n    // #region _applyRule\n    _applyRule(word, rule) {\n        const entries = rule.entries;\n        let newWords = [];\n        // if (!entries) {\n        // \treturn newWords;\n        // }\n        for (const entry of entries) {\n            if (!entry.match || word.match(entry.match)) {\n                let newWord = word;\n                if (entry.remove) {\n                    newWord = newWord.replace(entry.remove, \"\");\n                }\n                if (rule.type === \"SFX\") {\n                    newWord = newWord + entry.add;\n                }\n                else {\n                    newWord = entry.add + newWord;\n                }\n                newWords.push(newWord);\n                if (entry.continuationClasses) {\n                    entry.continuationClasses.map(key => {\n                        const continuationRule = this.rules[key];\n                        if (continuationRule) {\n                            newWords = newWords.concat(this._applyRule(newWord, continuationRule));\n                        }\n                        /*\n                    else {\n                        // This shouldn't happen, but it does, at least in the de_DE dictionary.\n                        // I think the author mistakenly supplied lower-case rule codes instead\n                        // of upper-case.\n                    }\n                    */\n                    });\n                }\n            }\n        }\n        return newWords;\n    }\n    // #endregion _applyRule\n    //#region init\n    //#endregion init\n    // #region parseRuleCodes\n    /**\n     *\n     * @param {string} textCodes\n     */\n    parseRuleCodes(textCodes) {\n        if (!textCodes || this.flags === undefined) {\n            return [];\n        }\n        else if (!(this.flags.FLAG)) {\n            return textCodes.split(\"\");\n        }\n        else if (this.flags.FLAG === \"long\") {\n            const pFlags = [];\n            for (let i = 0; i < textCodes.length; i += 2) {\n                pFlags.push(textCodes.substr(i, 2));\n            }\n            return pFlags;\n        }\n        else if (this.flags.FLAG === \"num\") {\n            return textCodes.split(\",\");\n        }\n        return [];\n    }\n    // #endregion parseRuleCodes\n    //#region check Methods\n    /**\n     * Checks whether a word or a capitalization variant exists in the current dictionary.\n     * The word is trimmed and several variations of capitalizations are checked.\n     * If you want to check a word without any changes made to it, call checkExact()\n     *\n     * @see http://blog.stevenlevithan.com/archives/faster-trim-javascript re:trimming function\n     *\n     * @param {string} aWord The word to check.\n     * @returns {boolean}\n     */\n    check(aWord) {\n        if (!this.loaded) {\n            throw new Error(this.ERR_NOT_LOAD);\n        }\n        if (aWord.length === 0) {\n            return false;\n        }\n        // Remove leading and trailing whitespace\n        const trimmedWord = aWord.replace(/^\\s\\s*/, '').replace(/\\s\\s*$/, '');\n        if (this.checkExact(trimmedWord)) {\n            return true;\n        }\n        // The exact word is not in the dictionary.\n        if (trimmedWord.toUpperCase() === trimmedWord) {\n            // The word was supplied in all uppercase.\n            // Check for a capitalized form of the word.\n            const capitalizedWord = trimmedWord[0] + trimmedWord.substring(1).toLowerCase();\n            if (this.hasFlag(capitalizedWord, \"KEEPCASE\")) { // Capitalization variants are not allowed for this word.\n                return false;\n            }\n            if (this.checkExact(capitalizedWord)) {\n                return true;\n            }\n        }\n        const lowercaseWord = trimmedWord.toLowerCase();\n        if (lowercaseWord !== trimmedWord) {\n            if (this.hasFlag(lowercaseWord, \"KEEPCASE\")) { // Capitalization variants are not allowed for this word.\n                return false;\n            }\n            // Check for a lowercase form\n            if (this.checkExact(lowercaseWord)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    //#endregion\n    //#region checkExact method\n    /**\n    * Checks whether a word exists in the current dictionary.\n    *\n    * @param {string} word The word to check.\n    * @returns {boolean}\n    */\n    checkExact(word) {\n        if (!this.loaded) {\n            throw new Error(this.ERR_NOT_LOAD);\n        }\n        if (word.length === 0) {\n            return false;\n        }\n        const ruleCodes = this.dictionaryTable[word];\n        if (typeof ruleCodes === 'undefined') { // Check if this might be a compound word.\n            if ((this.flags.COMPOUNDMIN) && (word.length >= this.flags.COMPOUNDMIN)) {\n                for (const rule of this.compoundRules) {\n                    if (word.match(rule)) {\n                        return true;\n                    }\n                }\n            }\n        }\n        else if (ruleCodes === null) {\n            // a null (but not undefined) value for an entry in the dictionary table\n            // means that the word is in the dictionary but has no flags.\n            return true;\n        }\n        else if (typeof ruleCodes === 'object') { // this.dictionary['hasOwnProperty'] will be a function.\n            for (const ruleCode of ruleCodes) {\n                if ((ruleCode !== null)\n                    && !(this.hasFlag(word, \"ONLYINCOMPOUND\", ruleCode))) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    //#endregion\n    //#region hasFlag\n    /**\n     * Looks up whether a given word is flagged with a given flag.\n     *\n     * @param {string} word The word in question.\n     * @param {string} strFlag The flag in question.\n     * @param {any} [wordFlags]\n     * @return {boolean}\n     */\n    hasFlag(word, strFlag, wordFlags) {\n        if (!this.loaded) {\n            throw new Error(this.ERR_NOT_LOAD);\n        }\n        const flattenArr = (arr) => {\n            const ar = [];\n            for (const a of arr)\n                for (const s of a)\n                    ar.push(s);\n            return ar;\n        };\n        if (strFlag in this.flags) {\n            if (typeof wordFlags === 'undefined') {\n                const tableItem = this.dictionaryTable[word];\n                if (tableItem !== undefined && tableItem !== null) {\n                    wordFlags = flattenArr(tableItem); // only interested in index of a key\n                }\n                else {\n                    wordFlags = [];\n                }\n            }\n            if (wordFlags && wordFlags.indexOf(this.flags[strFlag]) >= 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n    //#endregion hasFlag\n    //#region suggest method\n    /**\n    * Returns a list of suggestions for a misspelled word.\n    *\n    * @see http://www.norvig.com/spell-correct.html for the basis of this suggestor.\n    * This suggestor is primitive, but it works.\n    *\n    * @param {string} word The misspelling.\n    * @param {number} [limit=5] The maximum number of suggestions to return.\n    * @returns {string[]} The array of suggestions.\n    */\n    suggest(word, limit = 5) {\n        if (!this.loaded) {\n            throw new Error(this.ERR_NOT_LOAD);\n        }\n        if (this.memoized.hasOwnProperty(word)) {\n            const memoizedLimit = this.memoized[word]['limit'];\n            // Only return the cached list if it's big enough or if there weren't enough suggestions\n            // to fill a smaller limit.\n            if (limit <= memoizedLimit || this.memoized[word]['suggestions'].length < memoizedLimit) {\n                return this.memoized[word]['suggestions'].slice(0, limit);\n            }\n        }\n        if (this.check(word))\n            return [];\n        // Check the replacement table.\n        for (const replacementEntry of this.replacementTable) {\n            if (word.indexOf(replacementEntry[0]) !== -1) {\n                const correctedWord = word.replace(replacementEntry[0], replacementEntry[1]);\n                if (this.check(correctedWord)) {\n                    return [correctedWord];\n                }\n            }\n        }\n        /*\n        if (!self.alphabet) {\n            // Use the alphabet as implicitly defined by the words in the dictionary.\n            var alphaHash = {};\n            \n            for (var i in self.dictionaryTable) {\n                for (var j = 0, _len = i.length; j < _len; j++) {\n                    alphaHash[i[j]] = true;\n                }\n            }\n            \n            for (var i in alphaHash) {\n                self.alphabet += i;\n            }\n            \n            var alphaArray = self.alphabet.split(\"\");\n            alphaArray.sort();\n            self.alphabet = alphaArray.join(\"\");\n        }\n        */\n        /**\n         * Returns a hash keyed by all of the strings that can be made\n         * by making a single edit to the word (or words in) `words`\n         * The value of each entry is the number of unique ways that the\n         * resulting word can be made.\n         * @param words words Either a hash keyed by words or a string word to operate on.\n         * @param {boolean} [knownOnly=false] known_only Whether this function should ignore strings that are not in the dictionary.\n         */\n        const edits1 = (words, knownOnly = false) => {\n            const rv = {};\n            let i;\n            let j;\n            let numLen;\n            let numJlen;\n            let strEdit;\n            if (typeof words === 'string') {\n                const wrd = words;\n                words = {};\n                words[wrd] = 1;\n            }\n            for (const wrd in words) {\n                if (Object.prototype.hasOwnProperty.call(words, wrd)) {\n                    // const wd = words[wd];\n                    for (i = 0, numLen = wrd.length + 1; i < numLen; i++) {\n                        const strSub = [wrd.substring(0, i), wrd.substring(i)];\n                        if (strSub[1]) {\n                            strEdit = strSub[0] + strSub[1].substring(1);\n                            if (!knownOnly || this.check(strEdit)) {\n                                if (!(strEdit in rv)) {\n                                    rv[strEdit] = 1;\n                                }\n                                else {\n                                    rv[strEdit] += 1;\n                                }\n                            }\n                        }\n                        // Eliminate transpositions of identical letters\n                        if (strSub[1].length > 1 && strSub[1][1] !== strSub[1][0]) {\n                            strEdit = strSub[0] + strSub[1][1] + strSub[1][0] + strSub[1].substring(2);\n                            if (!knownOnly || this.check(strEdit)) {\n                                if (!(strEdit in rv)) {\n                                    rv[strEdit] = 1;\n                                }\n                                else {\n                                    rv[strEdit] += 1;\n                                }\n                            }\n                        }\n                        if (strSub[1]) {\n                            for (j = 0, numJlen = this.ALPHABET.length; j < numJlen; j++) {\n                                // Eliminate replacement of a letter by itself\n                                if (this.ALPHABET[j] !== strSub[1].substring(0, 1)) {\n                                    strEdit = strSub[0] + this.ALPHABET[j] + strSub[1].substring(1);\n                                    if (!knownOnly || this.check(strEdit)) {\n                                        if (!(strEdit in rv)) {\n                                            rv[strEdit] = 1;\n                                        }\n                                        else {\n                                            rv[strEdit] += 1;\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                        if (strSub[1]) {\n                            for (j = 0, numJlen = this.ALPHABET.length; j < numJlen; j++) {\n                                strEdit = strSub[0] + this.ALPHABET[j] + strSub[1];\n                                if (!knownOnly || this.check(strEdit)) {\n                                    if (!(strEdit in rv)) {\n                                        rv[strEdit] = 1;\n                                    }\n                                    else {\n                                        rv[strEdit] += 1;\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            return rv;\n        };\n        const correct = (wrd) => {\n            // Get the edit-distance-1 and edit-distance-2 forms of this word.\n            const ed1 = edits1(wrd);\n            const ed2 = edits1(ed1, true);\n            // Sort the edits based on how many different ways they were created.\n            const weightedCorrections = ed2;\n            for (const ed1word in ed1) {\n                if (!this.check(ed1word)) {\n                    continue;\n                }\n                if (ed1word in weightedCorrections) {\n                    weightedCorrections[ed1word] += ed1[ed1word];\n                }\n                else {\n                    weightedCorrections[ed1word] = ed1[ed1word];\n                }\n            }\n            let i;\n            const sortedCorrections = [];\n            for (const j in weightedCorrections) {\n                // if (Object.prototype.hasOwnProperty.call(weighted_corrections, i)) {\n                // \tsorted_corrections.push([i, weighted_corrections[i]]);\n                // }\n                if (weightedCorrections.hasOwnProperty(j)) {\n                    sortedCorrections.push([j, weightedCorrections[j]]);\n                }\n            }\n            const sorter = (a, b) => {\n                // frist eleement is the word if a and b\n                // second element of a and b is numeric values\n                const aVal = a[1];\n                const bVal = b[1];\n                if (aVal < bVal) {\n                    return -1;\n                }\n                else if (aVal > bVal) {\n                    return 1;\n                }\n                // @todo If a and b are equally weighted, add our own weight based on something like the key locations on this language's default keyboard.\n                return b[0].toString().localeCompare(a[0].toString());\n            };\n            sortedCorrections.sort(sorter).reverse();\n            const rv = [];\n            let capitalizationScheme = \"lowercase\";\n            if (wrd.toUpperCase() === wrd) {\n                capitalizationScheme = \"uppercase\";\n            }\n            else if (wrd.substr(0, 1).toUpperCase() + wrd.substr(1).toLowerCase() === wrd) {\n                capitalizationScheme = \"capitalized\";\n            }\n            let workingLimit = limit;\n            for (i = 0; i < Math.min(workingLimit, sortedCorrections.length); i++) {\n                let sortString = sortedCorrections[i][0].toString();\n                let update = false;\n                if (\"uppercase\" === capitalizationScheme) {\n                    sortString = sortString.toUpperCase();\n                    update = true;\n                }\n                else if (\"capitalized\" === capitalizationScheme) {\n                    sortString = sortString.substr(0, 1).toUpperCase() + sortString.substr(1);\n                    update = true;\n                }\n                if (!this.hasFlag(sortString, \"NOSUGGEST\") && rv.indexOf(sortString) === -1) {\n                    rv.push(sortString);\n                }\n                else {\n                    // If one of the corrections is not eligible as a suggestion , make sure we still return the right number of suggestions.\n                    workingLimit++;\n                }\n                if (update) {\n                    sortedCorrections[i][0] = sortString;\n                }\n            }\n            return rv;\n        };\n        this.memoized[word] = {\n            'suggestions': correct(word),\n            'limit': limit\n        };\n        return this.memoized[word]['suggestions'];\n    }\n}\n"],"names":["Typo","dictionary","affData","wordsData","settings","ERR_NOT_LOAD","ALPHABET","lDictionary","rules","dictionaryTable","compoundRules","compoundRuleCodes","replacementTable","Array","memoized","loaded","options","flags","undefined","readDataFile","url","response","_readFile","init","dic","aff","wData","setAffData","data","setup","setWordsData","_parseAFF","rule","j","length","charAt","ONLYINCOMPOUND","_parseDIC","iKey","Object","prototype","hasOwnProperty","call","i","ruleText","expressionText","character","join","RegExp","isChromeExt","window","chrome","runtime","getURL","isBrowserExt","browser","path","pLoadDataAff","pLoadDataDic","dictionaryPath","then","affD","wordsD","__dirname","Promise","resolve","reject","all","catch","err","readyPromise","loadedCallback","ready","obj","val","defineProperty","toString","value","writable","enumerable","configurable","charset","requestHeaders","Headers","set","fetch","method","headers","text","require","fs","result","existsSync","readFileSync","Error","e","line","subline","numEntries","lineParts","iLen","jLen","_removeAffixComments","lines","split","definitionParts","ruleType","toUpperCase","ruleCode","combineable","parseInt","entries","isNaN","charactersToRemove","additionParts","charactersToAdd","continuationClasses","parseRuleCodes","regexToMatch","entry","add","match","remove","push","str","replace","_removeDicComments","addWord","key","el","parts","word","ruleCodesArray","NEEDAFFIX","indexOf","jlen","code","newWords","_applyRule","newWord","k","combineCode","combineRule","type","otherNewWords","otherNewWord","trim","map","continuationRule","concat","textCodes","FLAG","pFlags","substr","aWord","trimmedWord","checkExact","capitalizedWord","substring","toLowerCase","hasFlag","lowercaseWord","ruleCodes","COMPOUNDMIN","strFlag","wordFlags","flattenArr","arr","ar","a","s","tableItem","limit","memoizedLimit","slice","check","replacementEntry","correctedWord","edits1","words","knownOnly","rv","numLen","numJlen","strEdit","wrd","strSub","correct","ed1","ed2","weightedCorrections","ed1word","sortedCorrections","sorter","b","aVal","bVal","localeCompare","sort","reverse","capitalizationScheme","workingLimit","Math","min","sortString","update","doCallBacks","t","forEach","fn"],"mappings":"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"}