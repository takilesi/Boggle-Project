declare type typeoLoadedCallback = (err: any, typo: Typo) => void;
interface ILooseObject {
    [key: string]: any;
}
interface IFlags extends ILooseObject {
    ONLYINCOMPOUND?: string;
    FLAG?: string;
    NEEDAFFIX?: string;
    COMPOUNDMIN?: number;
}
interface IOptions {
    flags: IFlags;
    dictionaryPath?: string;
    loadedCallback?: typeoLoadedCallback | Array<typeoLoadedCallback>;
}
/**
 * Typo is a JavaScript implementation of a spellchecker using hunspell-style
 * dictionaries.
 */
export declare class Typo {
    private readyPromise;
    private ERR_NOT_LOAD;
    private ALPHABET;
    private options;
    private lDictionary;
    /**
    * Object that will contain and entry of IRuleCodes for each
    * dynamically added key
    */
    private rules;
    private dictionaryTable;
    private compoundRules;
    private compoundRuleCodes;
    private replacementTable;
    private flags;
    private memoized;
    private loaded;
    /**
     * Typo constructor.
     * @param {string} [dictionary] The locale code of the dictionary being used.e.g.,
     * "en_US".This is only used to auto - load dictionaries.
     * @param {String} [affData] The data from the dictionary 's .aff file. If omitted
     * and Typo.js is being used in a Chrome extension, the.aff
     * file will be loaded automatically from
     * lib / typo / dictionaries / [dictionary] / [dictionary].aff
     * In other environments,it will be loaded from
     * [settings.dictionaryPath] / dictionaries / [dictionary] / [dictionary].aff
     * @param {String} [wordsData] The data from the dictionary 's .dic file. If omitted
     * and Typo.js is being used in a Chrome extension, the.dic
     * file will be loaded automatically from * lib / typo / dictionaries / [dictionary] / [dictionary].dic
     * In other environments, it will be loaded from
     * [settings.dictionaryPath] / dictionaries / [dictionary] / [dictionary].dic
     * @param {Object} [settings] Constructor settings.Available properties are :
     * {String}[dictionaryPath] : path to load dictionary from in non - chrome
     * environment.
     * {Object}[flags] : flag information.
     * {Boolean}[asyncLoad] : If true, affData and wordsData will be loaded
     * asynchronously.
     * {Function}[loadedCallback] : Called when both affData and wordsData
     * have been loaded.Only used if asyncLoad is set to true.The parameter
     * is the instantiated Typo object.
     */
    constructor(dictionary?: string, affData?: string, wordsData?: string, settings?: IOptions);
    get ready(): Promise<this>;
    get dictionary(): string | null;
    /**
     * Loads a Typo instance from a hash of all of the Typo properties.
     *
     * @param {object} obj A hash of Typo properties, probably gotten from a JSON.parse(JSON.stringify(typo_instance)).
     */
    load(obj: any): this;
    /**
     * Read the contents of a file.
     *
     * @param {String} path The path (relative) to the file.
     * @param {String|null} charset The expected charset of the file, If null default to utf8
     * @param {Boolean} async If true, the file will be read asynchronously. For node.js this does nothing, all
     * files are read synchronously.
     * @returns {String} The file data if async is false, otherwise a promise object. If running node.js, the data is
     * always returned.
     */
    private _readFile;
    private _parseAFF;
    /**
         * Removes comment lines and then cleans up blank lines and trailing whitespace.
         *
         * @param {String} data The data from an affix file.
         * @return {String} The cleaned-up data.
         */
    _removeAffixComments(data: string): string;
    /**
     * Parses the words out from the .dic file.
     *
     * @param {String} data The data from the dictionary file.
     * @returns object The lookup table containing all of the words and
     *                 word forms from the dictionary.
    * The dictionary table looks similar to the folowng.
    * Note the dictionary table can have more than 20,000 entries
    ````js
        var dictionaryTable = {
            "1": [["n", "m"]],
            "2": [["n", "1"]],
            "d": [["J", "G", "V", "X"]]
            };
     ````
     */
    private _parseDIC;
    /**
     * Removes comment lines and then cleans up blank lines and trailing whitespace.
     *
     * @param {String} data The data from a .dic file.
     * @return {String} The cleaned-up data.
     */
    private _removeDicComments;
    private _applyRule;
    /**
     *
     * @param {string} textCodes
     */
    private parseRuleCodes;
    /**
     * Checks whether a word or a capitalization variant exists in the current dictionary.
     * The word is trimmed and several variations of capitalizations are checked.
     * If you want to check a word without any changes made to it, call checkExact()
     *
     * @see http://blog.stevenlevithan.com/archives/faster-trim-javascript re:trimming function
     *
     * @param {string} aWord The word to check.
     * @returns {boolean}
     */
    check(aWord: string): boolean;
    /**
    * Checks whether a word exists in the current dictionary.
    *
    * @param {string} word The word to check.
    * @returns {boolean}
    */
    checkExact(word: string): boolean;
    /**
     * Looks up whether a given word is flagged with a given flag.
     *
     * @param {string} word The word in question.
     * @param {string} strFlag The flag in question.
     * @param {any} [wordFlags]
     * @return {boolean}
     */
    hasFlag(word: string, strFlag: string, wordFlags?: string | string[]): boolean;
    /**
    * Returns a list of suggestions for a misspelled word.
    *
    * @see http://www.norvig.com/spell-correct.html for the basis of this suggestor.
    * This suggestor is primitive, but it works.
    *
    * @param {string} word The misspelling.
    * @param {number} [limit=5] The maximum number of suggestions to return.
    * @returns {string[]} The array of suggestions.
    */
    suggest(word: string, limit?: number): string[];
}
export {};
